using Mirror;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Direction enum used mostly for indicating the direction of the sweepers.
/// </summary>
public enum Direction
{
    Up, Left, Right
}

public class NetworkObstacle : NetworkBehaviour
{
    #region Fields

    private GameScreen screen;
    private MyNetworkManager netManager;
    private GameManager manager;
    private GameObject obstacle;
    private GameObject killTrigger;

    [Header("Generator Settings")]
    [SerializeField] private float holeTolerance;

    [Header("Runtime Variables")]
    [SerializeField] private float speed;

    [SerializeField] private float speedMultiplier;
    [SerializeField] private float maxSpeed;
    [SerializeField] private Direction direction;

#if UNITY_EDITOR

    [Header("GUI Options")]
    [SerializeField] private bool showGUI;

    [SerializeField] private Vector2 guiOffset;
#endif
    private List<float> holes = new List<float>();

    #endregion Fields

    /// <summary>
    /// This function will generate new float points as hole points and new sweeper direction.
    /// </summary>
    /// <returns>True, if the function runs properly</returns>
    [Server]
    private bool GenerateObstacle()
    {
        holes.Clear();
        //RNG: determine where obstacle will originate
        {
            var num = Random.Range(0f, 1f);
            var holeCount = Mathf.Clamp(Random.Range(manager.PlayerCount - 2, manager.PlayerCount), 1, 5);
            holeTolerance = Mathf.Clamp(manager.PlayerCount / holeCount, 1f, 2.5f);
            var num2 = screen.ScreenHeight_inWorldUnits / holeCount;
            //Chance 25% right
            if (num < 0.25f)
            {
                direction = Direction.Right;
            }
            //Chance 25% left
            else if (num < 0.5f)
            {
                direction = Direction.Left;
            }
            //Chance 50% up
            else
            {
                num2 = screen.ScreenWidth_inWorldUnits / holeCount;
                direction = Direction.Up;
            }
            //Generate a list of holes position
            {
                var temp = new List<float>();
                for (short i = 0; i < holeCount; i++)
                {
                    if (direction != Direction.Up)
                    {
                        temp.Add(Random.Range(i * num2, (i + 1) * num2) - screen.ScreenHeight_inWorldUnits / 2);
                    }
                    else
                    {
                        temp.Add(Random.Range(i * num2, (i + 1) * num2) - screen.ScreenWidth_inWorldUnits / 2);
                    }
                }
                temp.Sort();
                for (short i = 0; i < holeCount; i++)
                {
                    holes.Add(temp[i]);
                }
            }
        }
        return true;
    }

    /// <summary>
    /// This function will instantiate a set of sweepers with conditions generated by the <c>GenerateObstacle()</c> function.
    /// </summary>
    /// <returns>True, if the function runs properly</returns>
    [Server]
    private bool CreateObstacle()
    {
        var size = obstacle.GetComponent<SpriteRenderer>().bounds.size;
        Vector2 vel = Vector2.zero;
        //First obstacle
        {
            var instance = Instantiate(obstacle, transform);
            instance.transform.localScale = new Vector3(1, (screen.Corner_TopRight.y - (holes[holes.Count - 1] + holeTolerance)) / size.y, 1);
            switch (direction)
            {
                case Direction.Left:
                    instance.transform.localPosition = new Vector3(screen.Corner_TopRight.x + 1f, holes[holes.Count - 1] + holeTolerance);
                    vel = new Vector2(-speed, 0);
                    break;

                case Direction.Right:
                    instance.transform.localPosition = new Vector3(screen.Corner_BottomLeft.x - 1f, holes[holes.Count - 1] + holeTolerance);
                    vel = new Vector2(speed, 0);
                    break;

                case Direction.Up:
                    instance.transform.localPosition = new Vector3(holes[holes.Count - 1] + holeTolerance, screen.Corner_BottomLeft.y - 1f);
                    instance.transform.localScale = new Vector3((screen.Corner_TopRight.x - (holes[holes.Count - 1] + holeTolerance)) / size.x, 1, 1);
                    vel = new Vector2(0, speed);
                    break;
            }
            instance.GetComponent<ObstacleScript>().SetVelocity(vel);
            NetworkServer.Spawn(instance);
        }

        //first+1 -> holeCount-1 obstacle
        if (holes.Count > 1)
        {
            for (int i = holes.Count - 2; i > -1; i--)
            {
                var instance = Instantiate(obstacle, transform);
                instance.transform.localScale = new Vector3(1, (holes[i + 1] - holeTolerance - (holes[i] + holeTolerance)) / size.y, 1);
                switch (direction)
                {
                    case Direction.Left:
                        instance.transform.localPosition = new Vector3(screen.Corner_TopRight.x + 1f, holes[i] + holeTolerance);
                        vel = new Vector2(-speed, 0);
                        break;

                    case Direction.Right:
                        instance.transform.localPosition = new Vector3(screen.Corner_BottomLeft.x - 1f, holes[i] + holeTolerance);
                        vel = new Vector2(speed, 0);
                        break;

                    case Direction.Up:
                        instance.transform.localPosition = new Vector3(holes[i] + holeTolerance, screen.Corner_BottomLeft.y - 1f);
                        instance.transform.localScale = new Vector3((holes[i + 1] - holeTolerance - (holes[i] + holeTolerance)) / size.x, 1, 1);
                        vel = new Vector2(0, speed);
                        break;
                }
                instance.GetComponent<ObstacleScript>().SetVelocity(vel);
                NetworkServer.Spawn(instance);
            }
        }

        //Last obstacle
        {
            var instance = Instantiate(obstacle, transform);
            instance.transform.localScale = new Vector3(1, (holes[0] - holeTolerance - screen.Corner_BottomLeft.y) / size.y, 1);
            switch (direction)
            {
                case Direction.Left:
                    instance.transform.localPosition = new Vector3(screen.Corner_TopRight.x + 1f, screen.Corner_BottomLeft.y);
                    vel = new Vector2(-speed, 0);
                    break;

                case Direction.Right:
                    instance.transform.localPosition = new Vector3(screen.Corner_BottomLeft.x - 1f, screen.Corner_BottomLeft.y);
                    vel = new Vector2(speed, 0);
                    break;

                case Direction.Up: //Basically, down
                    instance.transform.localPosition = new Vector3(screen.Corner_BottomLeft.x, screen.Corner_BottomLeft.y - 1f);
                    instance.transform.localScale = new Vector3((holes[0] - holeTolerance - screen.Corner_BottomLeft.x) / size.x, 1, 1);
                    vel = new Vector2(0, speed);
                    break;
            }
            instance.GetComponent<ObstacleScript>().SetVelocity(vel);
            NetworkServer.Spawn(instance);
        }
        return true;
    }

    [Server]
    public void ServerStartGame()
    {
        var trigger = Instantiate(killTrigger);
        NetworkServer.Spawn(trigger);
    }

    public override void OnStartServer()
    {
        if (!(screen = FindObjectOfType<GameScreen>()))
            Debug.LogError($"{ToString()}: gameScreen not found");
        if (!(manager = FindObjectOfType<GameManager>()))
            Debug.LogError($"{ToString()}: gameManager not found");
        if (!(netManager = FindObjectOfType<MyNetworkManager>()))
            Debug.LogError($"{ToString()}: netManager not found");
        killTrigger = netManager.spawnPrefabs[0];
        obstacle = netManager.spawnPrefabs[1];
        speed = 5f;
        speedMultiplier = 5f;
        maxSpeed = 12f;
        GenerateObstacle();
        base.OnStartServer();
    }

    private void Update()
    {
        if (isServer)
        {
            if (manager.Running)
            {
                if (transform.childCount < 1)
                {
                    GenerateObstacle();
                    CreateObstacle();
                }
                if (speed < maxSpeed)
                {
                    speed += speedMultiplier / 100 * Time.deltaTime;
                }
            }
        }
    }

#if UNITY_EDITOR

    private void OnGUI()
    {
        if (!showGUI) return;
        GUILayout.BeginArea(new Rect(10 + guiOffset.x, 40 + guiOffset.y, 215, 9999));
        if (GUILayout.Button("Generate Obstacle"))
        {
            Debug.Log("Obstacle Generated? = " + GenerateObstacle().ToString());
        }
        if (GUILayout.Button("Create Obstacle"))
        {
            Debug.Log("Obstacle Created? = " + CreateObstacle().ToString());
        }
        GUILayout.Label("Number of holes = " + holes.Count);
        GUILayout.EndArea();
    }

    private void OnDrawGizmos()
    {
        foreach (float item in holes)
        {
            if (direction != Direction.Up)
            {
                Gizmos.DrawSphere(new Vector3(0, item), 0.1f);
            }
            else
            {
                Gizmos.DrawSphere(new Vector3(item, 0), 0.1f);
            }
        }
    }

#endif
}